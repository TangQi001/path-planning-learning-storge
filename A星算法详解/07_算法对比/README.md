# 07 算法对比

## 模块概述

本模块实现了三种经典路径搜索算法的对比分析：**A\***、**Dijkstra** 和 **贪心最佳优先算法**。通过可视化演示和性能指标，帮助深入理解不同算法的特点、优势和适用场景。

## 算法介绍

### 🔹 Dijkstra算法
- **发明者**: Edsger W. Dijkstra (1959年)
- **核心思想**: 从起点开始，逐步扩展到最短距离的未访问节点
- **评估函数**: f(n) = g(n) （只考虑实际代价）
- **特点**: 
  - ✅ 保证找到最优路径
  - ✅ 适用于所有非负权重图
  - ❌ 不使用启发信息，搜索范围大
  - ❌ 在大规模问题中效率较低

### 🔹 贪心最佳优先算法 (Greedy Best-First)
- **核心思想**: 总是选择看起来最接近目标的节点
- **评估函数**: f(n) = h(n) （只考虑启发函数）
- **特点**:
  - ✅ 搜索速度快，直奔目标
  - ✅ 内存使用相对较少
  - ❌ 不保证找到最优路径
  - ❌ 可能陷入局部最优或死胡同

### 🔹 A\*算法
- **发明者**: Peter Hart, Nils Nilsson, Bertram Raphael (1968年)
- **核心思想**: 结合实际代价和启发信息，平衡最优性和效率
- **评估函数**: f(n) = g(n) + h(n)
- **特点**:
  - ✅ 在启发函数可接受时保证最优解
  - ✅ 使用启发信息引导搜索
  - ✅ 平衡效率和最优性
  - ❌ 需要设计合适的启发函数

## 文件说明

### algorithms_comparison.py
- **功能**: 三种算法的完整实现和对比分析
- **核心类**:
  - `Node`: 节点数据结构
  - `PathfindingAlgorithms`: 算法实现集合
  - `AlgorithmComparator`: 算法对比器

## 运行方法

### 直接运行
```bash
cd 07_算法对比
python algorithms_comparison.py
```

### 选择测试场景
程序提供三种测试场景：
1. **Simple (5×5)**: 基础测试场景
2. **Complex (10×10)**: 复杂障碍物布局  
3. **Maze (10×10)**: 迷宫场景

## 可视化功能

### 颜色编码
- 🟢 **绿色**: 起点
- 🔴 **红色**: 终点
- ⬜ **白色**: 可通行区域
- ⬛ **黑色**: 障碍物
- 🔷 **浅蓝色**: 已探索节点
- 🟡 **黄色**: 最终路径

### 对比图表
1. **算法搜索可视化**: 显示每个算法的搜索过程和结果
2. **性能对比柱状图**: 对比探索节点数、执行时间、路径代价

## 性能指标

### 主要指标
- **探索节点数**: 算法搜索效率的直接体现
- **执行时间**: 算法运行速度（毫秒）
- **路径长度**: 找到路径的步数
- **路径代价**: 考虑移动代价的总成本
- **最优性**: 是否找到最优解

### 算法比较

| 算法 | 最优性保证 | 搜索效率 | 内存使用 | 启发信息 | 适用场景 |
|------|-----------|----------|----------|----------|----------|
| Dijkstra | ✅ 是 | ❌ 较低 | ❌ 较高 | ❌ 不使用 | 权重图、最短路径 |
| 贪心BFS | ❌ 否 | ✅ 很高 | ✅ 较低 | ✅ 仅启发 | 快速路径、实时系统 |
| A* | ✅ 条件性 | ✅ 高 | ⚖️ 中等 | ✅ 平衡使用 | 游戏AI、路径规划 |

## 算法实现细节

### 核心数据结构
```python
@dataclass
class Node:
    x: int                    # X坐标
    y: int                    # Y坐标
    g: float = float('inf')   # 实际代价 g(n)
    h: float = 0.0            # 启发函数值 h(n)
    f: float = float('inf')   # 总评估代价 f(n)
    parent: Optional['Node']  # 父节点（用于路径重构）
```

### 优先队列策略
- **Dijkstra**: 按 g(n) 排序（实际代价最小优先）
- **贪心BFS**: 按 h(n) 排序（启发值最小优先）
- **A\***: 按 f(n) = g(n) + h(n) 排序（总评估代价最小优先）

## 实验结果分析

### 典型性能表现

**简单场景 (5×5)**:
- Dijkstra: 探索较多节点，但保证最优
- 贪心BFS: 探索最少节点，速度最快
- A*: 平衡性能，通常接近最优

**复杂场景 (10×10)**:
- Dijkstra: 探索范围广，适合复杂权重图
- 贪心BFS: 可能找到次优路径，但速度优势明显
- A*: 在大多数情况下表现最佳

**迷宫场景**:
- Dijkstra: 系统性搜索，不会遗漏最优解
- 贪心BFS: 可能在复杂迷宫中表现不佳
- A*: 启发式引导有效，通常表现优秀

## 算法选择指南

### 选择Dijkstra算法当：
- 需要绝对保证最优解
- 图中边权重差异很大
- 没有好的启发函数
- 需要计算从一点到所有点的最短路径

### 选择贪心最佳优先算法当：
- 对速度要求极高
- 可以接受次优解
- 有很好的启发函数
- 实时系统或资源受限环境

### 选择A*算法当：
- 需要平衡最优性和效率
- 有合适的启发函数
- 经典的路径规划问题
- 游戏AI或机器人导航

## 扩展练习

### 1. 启发函数实验
尝试不同的启发函数：
```python
# 修改贪心和A*算法的启发函数
heuristic_methods = ['euclidean', 'manhattan', 'diagonal']
```

### 2. 自定义网格
创建自己的测试场景：
```python
custom_grid = [
    [0, 0, 1, 0, 0],
    [0, 1, 1, 1, 0],
    [0, 0, 0, 0, 0],
    # ... 更多行
]
```

### 3. 算法参数调整
- 调整移动代价（直线 vs 对角线）
- 尝试不同的权重函数
- 实现启发函数权重调节

## 理论延伸

### 时间复杂度分析
- **Dijkstra**: O((V + E) log V)
- **贪心BFS**: O(b^m) （b: 分支因子，m: 最大深度）
- **A\***: O(b^d) （d: 最优解深度）

### 启发函数性质
- **可接受性 (Admissible)**: h(n) ≤ h*(n)
- **一致性 (Consistent)**: h(n) ≤ c(n,n') + h(n')
- **支配性 (Dominance)**: h2(n) ≥ h1(n) 且都可接受

## 实际应用案例

### 游戏开发
- **Dijkstra**: 战略游戏中的影响力计算
- **贪心BFS**: 实时策略游戏中的快速路径
- **A\***: RPG游戏中的角色寻路

### 机器人导航
- **Dijkstra**: 全局路径规划
- **贪心BFS**: 紧急避障
- **A\***: 日常导航任务

### 网络路由
- **Dijkstra**: 最短路径协议 (OSPF)
- **贪心BFS**: 快速转发决策
- **A\***: QoS感知路由

## 下一步学习

完成算法对比学习后，建议：
1. 深入研究启发函数设计理论
2. 学习双向搜索等优化技术
3. 探索动态环境下的路径规划
4. 了解多目标路径优化问题

## 总结

通过本模块的学习，您应该能够：
- 理解三种算法的核心差异
- 根据应用场景选择合适的算法
- 分析算法性能和权衡因素
- 实现和优化路径搜索算法

这为进一步学习高级路径规划算法奠定了坚实基础！ 