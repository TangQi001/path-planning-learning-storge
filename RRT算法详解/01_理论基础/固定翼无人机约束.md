# å›ºå®šç¿¼æ— äººæœºRRTè·¯å¾„è§„åˆ’çº¦æŸè¯¦è§£

## ğŸ“ æ¦‚è¿°

å›ºå®šç¿¼æ— äººæœºåœ¨è·¯å¾„è§„åˆ’ä¸­é¢ä¸´ç€ç‹¬ç‰¹çš„çº¦æŸæŒ‘æˆ˜ï¼Œä¸»è¦æºäºå…¶**éå®Œæ•´æ€§(Non-holonomic)**ç‰¹å¾ã€‚ä¸åœ°é¢æœºå™¨äººä¸åŒï¼Œå›ºå®šç¿¼æ— äººæœºä¸èƒ½ä»»æ„è½¬å‘ï¼Œå¿…é¡»æ»¡è¶³æœ€å°è½¬å¼¯åŠå¾„ã€èˆªè¿¹è§’é™åˆ¶ç­‰çº¦æŸã€‚

## ğŸ›©ï¸ å›ºå®šç¿¼æ— äººæœºè¿åŠ¨å­¦æ¨¡å‹

### åŸºæœ¬è¿åŠ¨å­¦æ–¹ç¨‹

```mermaid
graph TD
    A[çŠ¶æ€å‘é‡] --> B[ä½ç½®: x, y, z]
    A --> C[èˆªå‘è§’: Ïˆ]  
    A --> D[èˆªè¿¹è§’: Î³]
    A --> E[é€Ÿåº¦: V]
    
    F[æ§åˆ¶è¾“å…¥] --> G[è½¬å¼¯è§’é€Ÿåº¦: Ï‰]
    F --> H[çˆ¬å‡è§’é€Ÿåº¦: Î³Ì‡]
```

**çŠ¶æ€æ–¹ç¨‹:**
```math
\begin{cases}
\dot{x} = V \cos(\gamma) \cos(\psi) \\
\dot{y} = V \cos(\gamma) \sin(\psi) \\
\dot{z} = V \sin(\gamma) \\
\dot{\psi} = \frac{g \tan(\phi)}{V \cos(\gamma)} \\
\dot{\gamma} = \frac{g(\sin(\alpha) - \cos(\gamma))}{V}
\end{cases}
```

å…¶ä¸­ï¼š
- $(x, y, z)$: ä½ç½®åæ ‡
- $\psi$: èˆªå‘è§’ (Heading)
- $\gamma$: èˆªè¿¹è§’ (Flight Path Angle)
- $V$: ç©ºé€Ÿ
- $\phi$: æ»šè½¬è§’ (Bank Angle)
- $\alpha$: è¿è§’ (Angle of Attack)

## ğŸ¯ ä¸»è¦çº¦æŸæ¡ä»¶

### 1. æœ€å°è½¬å¼¯åŠå¾„çº¦æŸ

**Dubinsè·¯å¾„çº¦æŸ:**
```math
R_{min} = \frac{V^2}{g \tan(\phi_{max})}
```

å…¶ä¸­ï¼š
- $R_{min}$: æœ€å°è½¬å¼¯åŠå¾„
- $V$: é£è¡Œé€Ÿåº¦
- $g$: é‡åŠ›åŠ é€Ÿåº¦
- $\phi_{max}$: æœ€å¤§æ»šè½¬è§’

```mermaid
graph LR
    A[è½¬å¼¯çº¦æŸ] --> B[æœ€å°è½¬å¼¯åŠå¾„]
    B --> C[å½±å“è·¯å¾„å¹³æ»‘æ€§]
    A --> D[æœ€å¤§æ»šè½¬è§’]
    D --> E[é™åˆ¶æœºåŠ¨èƒ½åŠ›]
```

### 2. çˆ¬å‡/ä¸‹é™çº¦æŸ

**èˆªè¿¹è§’é™åˆ¶:**
```math
\gamma_{min} \leq \gamma \leq \gamma_{max}
```

å…¸å‹å€¼ï¼š
- $\gamma_{max} = 15Â°$ (æœ€å¤§çˆ¬å‡è§’)
- $\gamma_{min} = -20Â°$ (æœ€å¤§ä¸‹é™è§’)

### 3. é€Ÿåº¦çº¦æŸ

**å¤±é€Ÿé€Ÿåº¦é™åˆ¶:**
```math
V_{stall} \leq V \leq V_{max}
```

### 4. åŠ é€Ÿåº¦çº¦æŸ

**è½½è·å› å­çº¦æŸ:**
```math
n_{min} \leq n \leq n_{max}
```

å…¶ä¸­è½½è·å› å­ï¼š
```math
n = \frac{L}{mg} = \frac{1}{\cos(\phi)}
```

## ğŸ”„ Dubinsè·¯å¾„åœ¨RRTä¸­çš„åº”ç”¨

### Dubinsè·¯å¾„ç±»å‹

```mermaid
graph TD
    A[Dubinsè·¯å¾„] --> B[CSCç±»å‹]
    A --> C[CCCç±»å‹]
    
    B --> D[LSL: Left-Straight-Left]
    B --> E[RSR: Right-Straight-Right]
    B --> F[LSR: Left-Straight-Right]
    B --> G[RSL: Right-Straight-Left]
    
    C --> H[LRL: Left-Right-Left]
    C --> I[RLR: Right-Left-Right]
```

### è·ç¦»è®¡ç®—

å¯¹äºCSCç±»å‹è·¯å¾„ï¼š
```math
L_{CSC} = R \cdot |\theta_1| + d + R \cdot |\theta_2|
```

å¯¹äºCCCç±»å‹è·¯å¾„ï¼š
```math
L_{CCC} = R \cdot (|\theta_1| + |\theta_2| + |\theta_3|)
```

## ğŸš 3D Dubinsè·¯å¾„æ‰©å±•

### èºæ—‹è¿åŠ¨æ¨¡å‹

```mermaid
graph LR
    A[3D Dubins] --> B[æ°´å¹³è½¬å¼¯]
    A --> C[èºæ—‹çˆ¬å‡]
    A --> D[èºæ—‹ä¸‹é™]
    
    B --> E[ä¿æŒé«˜åº¦]
    C --> F[å›ºå®šçˆ¬å‡ç‡]
    D --> G[å›ºå®šä¸‹é™ç‡]
```

**èºæ—‹è·¯å¾„å‚æ•°åŒ–:**
```math
\begin{cases}
x(t) = x_c + R \cos(\psi_0 + \omega t) \\
y(t) = y_c + R \sin(\psi_0 + \omega t) \\
z(t) = z_0 + V \sin(\gamma) \cdot t
\end{cases}
```

å…¶ä¸­ï¼š
- $(x_c, y_c)$: èºæ—‹ä¸­å¿ƒ
- $R$: è½¬å¼¯åŠå¾„
- $\omega = V\cos(\gamma)/R$: è§’é€Ÿåº¦
- $\gamma$: èˆªè¿¹è§’

## ğŸ“Š çº¦æŸä¸‹çš„RRT*æ”¹è¿›

### 1. çŠ¶æ€é‡‡æ ·ç­–ç•¥

```python
def sample_state():
    """é‡‡æ ·æ»¡è¶³çº¦æŸçš„çŠ¶æ€"""
    x = uniform(x_min, x_max)
    y = uniform(y_min, y_max) 
    z = uniform(z_min, z_max)
    psi = uniform(0, 2*pi)  # èˆªå‘è§’
    gamma = uniform(gamma_min, gamma_max)  # èˆªè¿¹è§’
    return [x, y, z, psi, gamma]
```

### 2. çº¦æŸæ‰©å±•å‡½æ•°

```mermaid
graph TD
    A[æ‰©å±•å‡½æ•°Steer] --> B[è®¡ç®—Dubinsè·¯å¾„]
    B --> C[æ£€æŸ¥çº¦æŸæ»¡è¶³]
    C --> D{çº¦æŸå¯è¡Œ?}
    D -->|æ˜¯| E[è¿”å›æ–°çŠ¶æ€]
    D -->|å¦| F[è°ƒæ•´å‚æ•°é‡è¯•]
    F --> B
```

### 3. ç¢°æ’æ£€æµ‹æ”¹è¿›

**åˆ†æ®µæ£€æµ‹:**
```python
def collision_check_dubins(path):
    """Dubinsè·¯å¾„ç¢°æ’æ£€æµ‹"""
    for segment in path.segments:
        if segment.type == 'straight':
            if not line_collision_free(segment):
                return False
        else:  # circular arc
            if not arc_collision_free(segment):
                return False
    return True
```

## ğŸ® å®é™…åº”ç”¨å‚æ•°

### å…¸å‹å›ºå®šç¿¼æ— äººæœºå‚æ•°

| å‚æ•° | ç¬¦å· | å…¸å‹å€¼ | å•ä½ |
|------|------|--------|------|
| å·¡èˆªé€Ÿåº¦ | $V$ | 25-30 | m/s |
| æœ€å°è½¬å¼¯åŠå¾„ | $R_{min}$ | 50-100 | m |
| æœ€å¤§çˆ¬å‡è§’ | $\gamma_{max}$ | 15 | Â° |
| æœ€å¤§ä¸‹é™è§’ | $\gamma_{min}$ | -20 | Â° |
| æœ€å¤§æ»šè½¬è§’ | $\phi_{max}$ | 45 | Â° |

### ç¯å¢ƒçº¦æŸ

```mermaid
graph TD
    A[ç¯å¢ƒçº¦æŸ] --> B[åœ°å½¢é™åˆ¶]
    A --> C[ç¦é£åŒº]
    A --> D[æ°”è±¡æ¡ä»¶]
    
    B --> E[æœ€ä½é£è¡Œé«˜åº¦]
    C --> F[é™æ€éšœç¢ç‰©]
    C --> G[åŠ¨æ€éšœç¢ç‰©]
    D --> H[é£åœºå½±å“]
    D --> I[æ¹æµåŒºåŸŸ]
```

## ğŸ”§ ç®—æ³•ä¼˜åŒ–ç­–ç•¥

### 1. è‡ªé€‚åº”é‡‡æ ·

æ ¹æ®å½“å‰æ ‘çš„è¦†ç›–æƒ…å†µè°ƒæ•´é‡‡æ ·ç­–ç•¥ï¼š
```python
def adaptive_sampling(tree, obstacles):
    """è‡ªé€‚åº”é‡‡æ ·ç­–ç•¥"""
    # è®¡ç®—Voronoiå›¾
    voronoi_regions = compute_voronoi(tree.vertices)
    
    # åœ¨ç¨€ç–åŒºåŸŸå¢åŠ é‡‡æ ·æ¦‚ç‡
    sparse_regions = find_sparse_regions(voronoi_regions)
    
    # è€ƒè™‘çº¦æŸçš„å¯è¾¾æ€§
    reachable_regions = filter_reachable(sparse_regions)
    
    return sample_from_regions(reachable_regions)
```

### 2. è·¯å¾„åå¤„ç†

```mermaid
graph LR
    A[åŸå§‹RRT*è·¯å¾„] --> B[Dubinsè·¯å¾„æ‹Ÿåˆ]
    B --> C[Bæ ·æ¡å¹³æ»‘]
    C --> D[çº¦æŸéªŒè¯]
    D --> E[æœ€ç»ˆèˆªè¿¹]
```

### 3. å¤šåˆ†è¾¨ç‡è§„åˆ’

```python
def multi_resolution_planning():
    """å¤šåˆ†è¾¨ç‡è·¯å¾„è§„åˆ’"""
    # ç²—ç²’åº¦å¿«é€Ÿè§„åˆ’
    coarse_path = rrt_star_coarse()
    
    # ç»†ç²’åº¦å±€éƒ¨ä¼˜åŒ–
    fine_path = refine_path(coarse_path)
    
    # çº¦æŸæ»¡è¶³éªŒè¯
    feasible_path = constraint_satisfaction(fine_path)
    
    return feasible_path
```

## ğŸ“ˆ æ€§èƒ½è¯„ä¼°æŒ‡æ ‡

### 1. è·¯å¾„è´¨é‡
- **è·¯å¾„é•¿åº¦**: $L = \sum_{i=1}^{n-1} d(x_i, x_{i+1})$
- **å¹³æ»‘åº¦**: $S = \sum_{i=1}^{n-2} |\theta_{i+1} - \theta_i|$
- **é«˜åº¦å˜åŒ–**: $H = \sum_{i=1}^{n-1} |z_{i+1} - z_i|$

### 2. çº¦æŸæ»¡è¶³åº¦
- **è½¬å¼¯åŠå¾„è¿å**: $V_R = \max(0, R_{req} - R_{min})$
- **èˆªè¿¹è§’è¿å**: $V_\gamma = \max(0, |\gamma| - \gamma_{max})$

### 3. è®¡ç®—æ•ˆç‡
- **è§„åˆ’æ—¶é—´**: $T_{plan}$
- **å†…å­˜ä½¿ç”¨**: $M_{usage}$
- **æ”¶æ•›è¿­ä»£æ•°**: $N_{iter}$

## ğŸ¯ åº”ç”¨åœºæ™¯ç¤ºä¾‹

### 1. ç¾åŒºæ•‘æ´
```mermaid
graph TD
    A[ç¾åŒºç¯å¢ƒ] --> B[å¤æ‚åœ°å½¢]
    A --> C[ç¦é£åŒºåŸŸ]
    A --> D[æ°”è±¡æ¡ä»¶]
    
    E[ä»»åŠ¡éœ€æ±‚] --> F[å¿«é€Ÿåˆ°è¾¾]
    E --> G[å®‰å…¨çº¦æŸ]
    E --> H[ç‡ƒæ–™é™åˆ¶]
```

### 2. å†œä¸šæ¤ä¿
- **å¤§é¢ç§¯è¦†ç›–**
- **é¿å¼€é£åœºå¹²æ‰°**
- **ä¼˜åŒ–å–·æ´’è·¯å¾„**

### 3. ä¾¦å¯Ÿç›‘è§†
- **é•¿è·ç¦»å·¡èˆª**
- **éšè”½æ€§è¦æ±‚**
- **å¤šç›®æ ‡è®¿é—®**

## ğŸ” æœªæ¥å‘å±•æ–¹å‘

### 1. æœºå™¨å­¦ä¹ å¢å¼º
```python
# ä½¿ç”¨ç¥ç»ç½‘ç»œé¢„æµ‹æœ€ä¼˜æ‰©å±•æ–¹å‘
def ml_enhanced_steer(current_state, target_state):
    """æœºå™¨å­¦ä¹ å¢å¼ºçš„æ‰©å±•å‡½æ•°"""
    features = extract_features(current_state, target_state)
    optimal_control = neural_network.predict(features)
    return apply_dubins_constraints(optimal_control)
```

### 2. å¤šç›®æ ‡ä¼˜åŒ–
- **èƒ½è€—æœ€å°åŒ–**
- **æ—¶é—´æœ€çŸ­è·¯å¾„**
- **é£é™©æœ€å°åŒ–**

### 3. ååŒè§„åˆ’
- **å¤šæœºç¼–é˜Ÿ**
- **ä»»åŠ¡åˆ†é…**
- **å†²çªé¿å…**

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. Dubins, L.E. "On Curves of Minimal Length with a Constraint on Average Curvature"
2. LaValle, S.M. "Rapidly-Exploring Random Trees: A New Tool for Path Planning"
3. Karaman, S. "Sampling-based Algorithms for Optimal Motion Planning"
4. Chitsaz, H. "Time-optimal Paths for a Dubins Airplane" 